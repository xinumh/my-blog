---
title: Vue-面试
date: 2020/08/12
sidebar: 'auto'
tags:
 - 面试
categories:
 -  面试
---

## v-if和v-for哪个优先级高？

v-for优先于v-if被解析。

如果同时出现，每次渲染都会先执行循环，在进行判断，无论如何不可避免循环，浪费了性能。

避免这种情况，可以在嵌套template，在这一层进行v-if判断，在内部进行v-for循环。

vue.$options.render渲染函数：

同级：列表渲染函数，循环输出children，函数里边每一项会判断v-if的值看是否渲染；

分层：会在列表渲染函数之前进行v-if判断，然后执行v-for循环。



如果需要列表每一项都需要判断状态，可以在computed里面对渲染列表进行过滤。render性能优化

## Vue组件中的data为什么是函数，Vue根实例没有限制？

在vue多实例的时候是函数，在vue根实例没有限制。



vue组件可能存在多个实例，如果使用对象形式定义data，则会导致他们共用一个data对象，那么状态变更将会影响所以组件实例，这是不合理的。

如果以函数形式定义data，在initdata时会将其作为工厂函数返回全新的data对象，有效的规避了多个组件实例之间状态污染问题。而vue根实例创建过程中不存在该限制，因为vue根实例只有一个。



## vue中key的作用和工作原理？

key的作用主要是为了高校的更新虚拟dom，其原理是vue在patch的过程中，通过ke以精准的判断两个节点是否是同一个，从而避免频繁更新不同元素，使得整个patch过程更加高效，减少Dom操作量，提高性能。



## 你怎么理解vue中diff算法？

diff算法是虚拟dom技术的必然产物，通过新旧虚拟dom对比，将变化的地方更新在真实dom上。另外也需要diff高效的执行对比过程，从而降低时间复杂度为O(n)。

diff过程整体遵循深度优先、同层比较的策略，两个节点之间比较会根据他们是否拥有子节点或者文本节点做不同操作。比较两组子节点是算法的重点，首先假设头尾节点相同做四次比对尝试，如果没有找到相同节点，则按照通用方式遍历查找，查找结束再按情况处理剩下节点。借助key通常可以精准的找到相同节点，因此，整个patch过程（新旧虚拟dom比较的过程）非常高效。



## vue组件通信？

* 组件通信分为不同场景：

  父子

  兄弟

  跨层级

* 通信方式

  props

  $emit/$on事件总线

  vuex 

  $parent/$children

  $attrs/$listeners

  Provide/reject



## vue中watch和computed的区别？

watch在数据变化时执行异步或者开销较大的操作，如搜索数据

computed底层来自watch，依赖项没有变化则从缓存中取值，缓存功能提升性能，更简单更高效，优先使用。一个属性受多个属性影响时使用，如购物车的结算。



## vue生命周期的理解？

## vue响应式？

在生成vue实例时，为对传入的data进行遍历，使用`Object.defineProperty`把这些属性转为`getter/setter`.

每个vue实例都有一个watcher实例，它会在实例渲染时记录这些属性，并在setter触发时重新渲染。



## vue双向绑定原理？

设计思想是观察者模式。

vue采用数据劫持结合发布者订阅模式通过Object.defineProperty()来劫持各个数据的getter、setter，在数据变动时，发布消息给订阅者，触发相应的监听回调。